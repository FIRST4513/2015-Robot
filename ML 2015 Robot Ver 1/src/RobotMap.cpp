// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
SpeedController* RobotMap::drivetrainLFSpeedCtrlr = NULL;
SpeedController* RobotMap::drivetrainFRSpeedCtrlr = NULL;
SpeedController* RobotMap::drivetrainRLSpeedCtrlr = NULL;
SpeedController* RobotMap::drivetrainRRSpeedCtrlr = NULL;
RobotDrive* RobotMap::drivetrainRobotDrive = NULL;
Encoder* RobotMap::drivetrainLFQuadratureEncoder = NULL;
Encoder* RobotMap::drivetrainRFQuadratureEncoder = NULL;
Gyro* RobotMap::drivetrainGyro = NULL;
DigitalInput* RobotMap::drivetrainContactLmtSw = NULL;
SpeedController* RobotMap::forkMotor = NULL;
DigitalInput* RobotMap::forkOutsideLmtSw = NULL;
DigitalInput* RobotMap::forkInsideLmtSw = NULL;
DigitalInput* RobotMap::forkContactLeft = NULL;
DigitalInput* RobotMap::forkContactRight = NULL;
SpeedController* RobotMap::elevMotor = NULL;
DigitalInput* RobotMap::elevTopLmtSw = NULL;
DigitalInput* RobotMap::elevBottomLmtSw = NULL;
DigitalInput* RobotMap::elevHitLmtSw = NULL;
Encoder* RobotMap::elevEncoder = NULL;
Relay* RobotMap::elevBrake = NULL;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION

void RobotMap::init() {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	LiveWindow* lw = LiveWindow::GetInstance();

	drivetrainLFSpeedCtrlr = new Talon(0);
	lw->AddActuator("Drivetrain", "LF Speed Ctrlr", (Talon*) drivetrainLFSpeedCtrlr);
	
	drivetrainFRSpeedCtrlr = new Talon(1);
	lw->AddActuator("Drivetrain", "FR Speed Ctrlr", (Talon*) drivetrainFRSpeedCtrlr);
	
	drivetrainRLSpeedCtrlr = new Talon(2);
	lw->AddActuator("Drivetrain", "RL Speed Ctrlr", (Talon*) drivetrainRLSpeedCtrlr);
	
	drivetrainRRSpeedCtrlr = new Talon(3);
	lw->AddActuator("Drivetrain", "RR Speed Ctrlr", (Talon*) drivetrainRRSpeedCtrlr);
	
	drivetrainRobotDrive = new RobotDrive(drivetrainLFSpeedCtrlr, drivetrainRLSpeedCtrlr,
              drivetrainFRSpeedCtrlr, drivetrainRRSpeedCtrlr);
	
	drivetrainRobotDrive->SetSafetyEnabled(false);
        drivetrainRobotDrive->SetExpiration(0.1);
        drivetrainRobotDrive->SetSensitivity(0.5);
        drivetrainRobotDrive->SetMaxOutput(1.0);

        drivetrainRobotDrive->SetInvertedMotor(RobotDrive::kFrontRightMotor, true);
        drivetrainRobotDrive->SetInvertedMotor(RobotDrive::kRearRightMotor, true);
	drivetrainLFQuadratureEncoder = new Encoder(0, 1, false, Encoder::k4X);
	lw->AddSensor("Drivetrain", "LF Quadrature Encoder", drivetrainLFQuadratureEncoder);
	drivetrainLFQuadratureEncoder->SetDistancePerPulse(0.017686);
        drivetrainLFQuadratureEncoder->SetPIDSourceParameter(Encoder::kRate);
	drivetrainRFQuadratureEncoder = new Encoder(2, 3, false, Encoder::k4X);
	lw->AddSensor("Drivetrain", "RF Quadrature Encoder", drivetrainRFQuadratureEncoder);
	drivetrainRFQuadratureEncoder->SetDistancePerPulse(0.017686);
        drivetrainRFQuadratureEncoder->SetPIDSourceParameter(Encoder::kRate);
	drivetrainGyro = new Gyro(0);
	lw->AddSensor("Drivetrain", "Gyro", drivetrainGyro);
	drivetrainGyro->SetSensitivity(0.007);
	drivetrainContactLmtSw = new DigitalInput(21);
	lw->AddSensor("Drivetrain", "ContactLmtSw", drivetrainContactLmtSw);
	
	forkMotor = new Talon(5);
	lw->AddActuator("Fork", "Motor", (Talon*) forkMotor);
	
	forkOutsideLmtSw = new DigitalInput(17);
	lw->AddSensor("Fork", "Outside Lmt Sw", forkOutsideLmtSw);
	
	forkInsideLmtSw = new DigitalInput(16);
	lw->AddSensor("Fork", "Inside Lmt Sw", forkInsideLmtSw);
	
	forkContactLeft = new DigitalInput(13);
	lw->AddSensor("Fork", "ContactLeft", forkContactLeft);
	
	forkContactRight = new DigitalInput(15);
	lw->AddSensor("Fork", "Contact Right", forkContactRight);
	
	elevMotor = new Talon(4);
	lw->AddActuator("Elev", "Motor", (Talon*) elevMotor);
	
	elevTopLmtSw = new DigitalInput(8);
	lw->AddSensor("Elev", "Top Lmt Sw", elevTopLmtSw);
	
	elevBottomLmtSw = new DigitalInput(7);
	lw->AddSensor("Elev", "Bottom Lmt Sw", elevBottomLmtSw);
	
	elevHitLmtSw = new DigitalInput(14);
	lw->AddSensor("Elev", "Hit Lmt Sw", elevHitLmtSw);
	
	elevEncoder = new Encoder(4, 5, true, Encoder::k4X);
	lw->AddSensor("Elev", "Encoder", elevEncoder);
	elevEncoder->SetDistancePerPulse(0.003742);
        elevEncoder->SetPIDSourceParameter(Encoder::kDistance);
	elevBrake = new Relay(0);
	lw->AddActuator("Elev", "Brake", elevBrake);
	


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
}
