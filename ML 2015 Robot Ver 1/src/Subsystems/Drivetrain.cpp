// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Drivetrain.h"
#include "../RobotMap.h"
#include "../Commands/DriveByJoystick.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

Drivetrain::Drivetrain() : Subsystem("Drivetrain") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	lFSpeedCtrlr = RobotMap::drivetrainLFSpeedCtrlr;
	fRSpeedCtrlr = RobotMap::drivetrainFRSpeedCtrlr;
	rLSpeedCtrlr = RobotMap::drivetrainRLSpeedCtrlr;
	rRSpeedCtrlr = RobotMap::drivetrainRRSpeedCtrlr;
	robotDrive = RobotMap::drivetrainRobotDrive;
	lFQuadratureEncoder = RobotMap::drivetrainLFQuadratureEncoder;
	rFQuadratureEncoder = RobotMap::drivetrainRFQuadratureEncoder;
	gyro = RobotMap::drivetrainGyro;
	contactLmtSw = RobotMap::drivetrainContactLmtSw;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


	InitVariables();		//Initialize variables
}
    
void Drivetrain::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	// SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new DriveByJoystick());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	lFQuadratureEncoder->SetDistancePerPulse(0.042);
	rFQuadratureEncoder->SetDistancePerPulse(0.042);
	gyro->InitGyro();	// may need time for this to stabilize
	gyro->SetDeadband( 0.015);
	gyro->Reset();
	gyroLastHdg = gyro->GetAngle();
 }


// **************************************************************
//       joystick to drive Mecanum Cartesian style.
// **************************************************************

void Drivetrain::Drive(Joystick* joy) {
	// Use the joystick X axis for lateral movement, Y axis for forward movement, and Z axis for rotation.
	// This sample does not use field-oriented drive, so the gyro input is set to zero.

	GetAxisValues(joy);								// Get joystick data and compute speeds

	if (topPov != -1){								// top POV switch selected !
		if (straightFirstTimeFlag == 0){			// is this the first time POV has been pressed?
			gyroLastHdg = gyro->GetAngle();			// Save heading to correct against
			straightFirstTimeFlag = 1;				// Reset flag so we dont keep saving the new heading
		}
		//  ----- Gyro compensated driving for straight motion -------
		CalculateCorrection();
		robotDrive->MecanumDrive_Cartesian(topxSpeed, topySpeed, correction);
	}
	else{											// Drive by regular joystick
		robotDrive->MecanumDrive_Cartesian(xSpeed, ySpeed, twistSpeed);
		straightFirstTimeFlag = 0; 	// reset flag so if top POV is selected later it will capture heading
	}
}

void Drivetrain::CalculateCorrection(){
	gyroHdg = gyro->GetAngle();
	origCorrection = ( - (gyroHdg-gyroLastHdg) * kGyroCorrectionConstant);
	correction = origCorrection;
	if (correction < 0){
		if (correction < kGyroCorrectionLwrLimit)  correction = kGyroCorrectionLwrLimit;
	}
	else
	{
		if (correction > kGyroCorrectionUpperLimit)  correction = kGyroCorrectionUpperLimit;
	}
//	printf("LastHd, %4.5f , CurrHd, %4.5f , Diff, %4.5f , Correction, %4.5f , Adj.Corr: %4.5f \n",
//			            gyroLastHdg, gyroHdg, gyroHdg-gyroLastHdg, origCorrection, correction);

}

// ----------------- Drive staight preliminary code -------------------
void Drivetrain::DriveStraight(float dir, float speed) {	// dir : 0 = Fwd/Back, 1 = Left/Right

	//  ----- Gyro compensated driving for straight motion -------
	if (straightFirstTimeFlag == 0){			// is this the first time POV has been pressed?
		gyroLastHdg = gyro->GetAngle();			// Save heading to correct against
		straightFirstTimeFlag = 1;				// Reset flag so we dont keep saving the new heading
	}
	CalculateCorrection();

	// Perform Motion
	if (dir == 0){		// this is a forward or backward direction
		robotDrive->MecanumDrive_Cartesian(0, speed,  correction);
		return;
	}
	robotDrive->MecanumDrive_Cartesian(speed, 0, correction);
}

// ----------------- Tank Drive -------------------------------
void Drivetrain::TankDrive(double left, double right) {
	robotDrive->TankDrive(left, right);
}

// ------------------ Stop Motors -------------------------------
void Drivetrain::Stop(){
	robotDrive->Drive( 0, 0);
}

// ------------------ Get Heading -------------------------------
double Drivetrain::GetHeading() {
	return gyro->GetAngle();
}
void Drivetrain::SetFirstTimeFlag(int val){
	straightFirstTimeFlag = val;
}

// ------------------ Reset Encoders -------------------
void Drivetrain::ResetEncoders() {
	lFQuadratureEncoder->Reset();
	rFQuadratureEncoder->Reset();
}
// ------------------ Reset Gyro -------------------
void Drivetrain::ResetGyro() {
	gyro->Reset();
}

// ------------------ Get Distance Traveled Fwd ---------------------
double Drivetrain::GetDistance() {
	return (((rFQuadratureEncoder->GetRaw() - lFQuadratureEncoder->GetRaw())/2) *kEncoderConvFwd);
}

// ------------------ Get Distance Traveled Lft/Rt ---------------------
double Drivetrain::GetHorizontalDistance(){
	// look only at left wheel (increase for left decreases for right)
	return (lFQuadratureEncoder->GetRaw()*kEncoderConvHorizontal);
}

// ------------------ Get Left Encoder ---------------------
double Drivetrain::GetLeftEncoder(){
	return (lFQuadratureEncoder->GetRaw());
}

// ------------------ Get Right Encoder ---------------------
double Drivetrain::GetRightEncoder(){
	return (rFQuadratureEncoder->GetRaw());
}


bool Drivetrain::GetContact(){							// Return if front ctr contact limit switch tripped
	if (contactLmtSw->Get() ==  kLmtSwPressed)
		return true;
	else
		return false;
}

// **************************************************************
//                  Calculate Speed Values from axis position
// **************************************************************
void Drivetrain::GetAxisValues(Joystick* joy){
	dThrottleAxis = joy->GetThrottle();
	dThrottle = ((dThrottleAxis-1) / -2);	// Convert value to (0 to +1) rather than (-1 to +1)

	xAxis = joy->GetX();
	yAxis = joy->GetY();
	twistAxis = joy->GetTwist();
	xSpeed = xAxis * dThrottle;
	ySpeed = yAxis * dThrottle;
	if ((ySpeed > (- kDeadband * dThrottle)) and ((ySpeed < ( kDeadband * dThrottle)))) ySpeed = 0;
	if ((xSpeed > (- kDeadband * dThrottle)) and ((xSpeed < ( kDeadband * dThrottle)))) xSpeed = 0;

	twistSpeed = twistAxis * dThrottle / kTwistConstant;
	if ((twistSpeed > (- kTwistDeadband * dThrottle)) and
	    (twistSpeed < ( kTwistDeadband * dThrottle))) {
			twistSpeed = 0;
	}

	// -----------------   Process top switch POV -------------------------
	topPov = joy->GetPOV();
	switch (topPov) {
	case -1:			// POV not Pressed
		topxSpeed = 0;
		topySpeed = 0;
		break;
	case 0:				// Forward
		topxSpeed = (  0 * dThrottle) / kTopPovFwdRvsConstant;
		topySpeed = ( -1 * dThrottle) / kTopPovFwdRvsConstant;
		break;
	case 180:			// Backwards
		topxSpeed = (0 * dThrottle) / kTopPovFwdRvsConstant;
		topySpeed = (1 * dThrottle) / kTopPovFwdRvsConstant;
		break;
	case 90:			// Right
		topxSpeed = (  1 * dThrottle) / kTopPovLftRtConstant;
		topySpeed = (  0 * dThrottle) / kTopPovLftRtConstant;
		break;
	case 270:			// Left
		topxSpeed = ( -1 * dThrottle) / kTopPovLftRtConstant;
		topySpeed = (  0 * dThrottle) / kTopPovLftRtConstant;
		break;
	case 45:			// Forward/Right
		topxSpeed = ( 1 * dThrottle) / kTopPovDiagConstant;
		topySpeed = (-1 * dThrottle) / kTopPovDiagConstant;
		break;
	case 135:			// Reverse/Right
		topxSpeed = ( 1 * dThrottle) / kTopPovDiagConstant;
		topySpeed = ( 1 * dThrottle) / kTopPovDiagConstant;
		break;
	case 225:			// Reverse/Left
		topxSpeed = ( -1 * dThrottle) / kTopPovDiagConstant;
		topySpeed = (  1 * dThrottle) / kTopPovDiagConstant;
		break;
	case 315:			// Forward/Left
		topxSpeed = ( -1 * dThrottle) / kTopPovDiagConstant;
		topySpeed = ( -1 * dThrottle) / kTopPovDiagConstant;
		break;
	default:			// POV not Pressed (-1 value)
		topxSpeed = 0;
		topySpeed = 0;
		break;
	}
}

// ***************************************************************************
//     The log method puts interesting information to the SmartDashboard.
// ***************************************************************************
void Drivetrain::Log(Joystick* joy) {
	// Get and Display Speeds from Joystick Input
	GetAxisValues(joy);
//	SmartDashboard::PutNumber("X-Speed", xSpeed);
//	SmartDashboard::PutNumber("Y-Speed",ySpeed);
//	SmartDashboard::PutNumber("Twist-Speed",twistSpeed);
//	SmartDashboard::PutNumber("D-Throttle",dThrottle);
//	SmartDashboard::PutNumber("TOPX-Speed",topxSpeed);
//	SmartDashboard::PutNumber("TOPY-Speed",topySpeed);

	// Display Drivetrain Sensors
//	SmartDashboard::PutNumber("Gyro", gyro->GetAngle());
//	SmartDashboard::PutNumber("Calculated Distance", lFQuadratureEncoder->GetRaw()* -.017686);
//	SmartDashboard::PutNumber("Left Distance", lFQuadratureEncoder->GetDistance());
//	SmartDashboard::PutNumber("Right Distance", rFQuadratureEncoder->GetDistance());
//	SmartDashboard::PutNumber("Left Raw", lFQuadratureEncoder->GetRaw());
//	SmartDashboard::PutNumber("Right Raw", rFQuadratureEncoder->GetRaw());
	SmartDashboard::PutNumber("Contact Ctr LmtSw",GetContact());
}
void Drivetrain::InitVariables(){
	Drivetrain::dThrottleAxis = 0;
	Drivetrain::dThrottle = 0;
	Drivetrain::xAxis = 0;
	Drivetrain::xSpeed = 0;
	Drivetrain::yAxis = 0;
	Drivetrain::ySpeed = 0;
	Drivetrain::twistAxis = 0;
	Drivetrain::twistSpeed = 0;
	Drivetrain::topxSpeed = 0;
	Drivetrain::topySpeed = 0;
	Drivetrain::topPov = 0;
	Drivetrain::deadband = 0.1;
	Drivetrain::gyroLastHdg = 0;
	Drivetrain::gyroHdg = 0;
	Drivetrain::gyroDrift = 0;
	Drivetrain::correction = 0;
	Drivetrain::origCorrection = 0;
	Drivetrain::straightFirstTimeFlag = 0;
}

